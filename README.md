# Тестовое задание Kopirka

В данном репозитории представлены решения 4 тестовых заданий. 

Файл с исходным описанием заданий можно найти по ссылке:  
https://docs.google.com/document/d/1DXPDkR_eLy-frEf0lJV-8ko--6smsyJ4FF1MbGw_AX4/edit


Для запуска *Codeception Unit* тестов проверки правильности выполнения функций необходимо находясь в папке проекта выполнить в терминале следующие команды:  

> 1. git clone https://github.com/PYIvanov/kopirka.git ./
> 2. composer install
> 3. composer tests

Результатом успешного выполнения тестов должно быть сообщение следующего вида:

```
Unit Tests (10) -----------------------------------------  
✔ GetCellTest: Get cell | #0 (0.00s)  
✔ GetCellTest: Get cell | #1 (0.00s)   
✔ GetCellTest: Get cell | #2 (0.00s)  
✔ GetCellTest: Get cell | #3 (0.00s)  
✔ GetCellTest: Get cell | #4 (0.00s)  
✔ RoundPriceTest: Round price | #0 (0.00s)  
✔ RoundPriceTest: Round price | #1 (0.00s)  
✔ RoundPriceTest: Round price | #2 (0.00s)  
✔ RoundPriceTest: Round price | #3 (0.00s)  
✔ RoundPriceTest: Round price | #4 (0.00s)  
--------------------------------------------------------- ` 
```


## Задание №1
Написать функцию получения номера ячейки Excel.  
Нумерация ячеек выглядит так:  
A1, B1, ..., Z1, AA1, AB1, ..., AZ1, BA1  
A2, B2, ..., Z2, AA2, AB2, ..., AZ2, BA2  
```php
/
* Получение номера ячейки Excel
* @param int $x
* @param int $y
* @return string
  */
  getCell(1, 1); // 'A1'
  getCell(26, 26); // 'Z26'
  getCell(28, 100); // 'AB100'
  getCell(55, 3); // 'BC3'
  getCell(4, 4); // 'D4'
```
Решение: [src/getCell.php](src/getCell.php)  
Сравнение результатов: [tests/unit/GetCellTest.php](tests/unit/GetCellTest.php)

Комментарии:  
&emsp;Представленная реализация функции *getCell*, не предполагает использование каких-либо сторонних библиотек вроде PHPExcel и др.
Предполагается, что функции *getCell* передаются корректные значения аргументов, прошедшие предварительную проверку.


## Задание №2
Написать функцию округления цен:  
```php
/*
* Округление стоимости в зависимости от размера
* 0-10: с точностью до 1
* 10-100: с точностью до 5
* 100-500: с точностью до 10
* 500-1000: с точностью до 25
* 1000-...: с точностью до 50
* @param int $num
* @return float|int
*/
  roundPrice(8.4); // 8
  roundPrice(8.5); // 9
  roundPrice(24); // 25
  roundPrice(523); // 500
  roundPrice(-100); // -100
```

Решение: [src/roundPrice.php](src/roundPrice.php)  
Сравнение результатов: [tests/unit/RoundPriceTest.php](tests/unit/RoundPriceTest.php)

Комментарии:  
&emsp;В примерах к условиям задачи есть некоторая неоднозначность. Например,
при точности округления 5 результат *roundPrice(24)* равен 25,
при точности округления 25 результат *roundPrice(523)* равен 500.
Получается, в первом случае округление осуществляется в большую сторону, в то время как во втором случае - в меньшую сторону.
Однако, это условие не прописано в исходных условиях задачи.
В случае необходимости применения различных подходов к округлению стоимости в большую или
меньшую сторону в зависимости от принадлежности к тому или иному диапазону
в коде скрипта следует использовать соответствующие функции *ceil* и *floor*.

## Задание №3

Что делает эта функция?
```javascript
function functionName(data) {
data = data || {};
const csrfParam = document.querySelector('meta[name="csrf-param"]').getAttribute('content');
const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
if (data instanceof FormData) {
data.append(csrfParam, csrfToken);
} else if (typeof data === 'string') {
data += '&' + encodeURIComponent(csrfParam) + '=' + encodeURIComponent(csrfToken);
} else {
data[csrfParam] = csrfToken;
}
return data;
}
```
Ответ :  
&emsp;Функция добавляет пару ключ-значение полей "*csrf-param*" и "*csrf-token*" из мета части страницы сайта к данным формы.
Скорее всего некоторые данные отправляются с помощью AJAX на сервер. Для защиты этих данных от возможной межсайтовой подделки
запросов вместе с данными передаётся специальный токен *CSRF*.


## Задание №4
Почему
```javascript
['1', '5', '112'].map(parseInt)
```
возвращает [1, NaN, 3] ?

Ответ:  
&emsp;При передаче функции в *map()* на каждой итерации исполнения скрипта
такая функция получает три аргумента: *currentValue*, *currentIndex* и *полный array*.
При этом передаваемая функция *parseInt* принимает лишь 2 аргумента - *string* и *radix* (основание).  
&emsp;Для нулевого элемента обрабатываемого массива ['1', '5', '112'] в качестве значения radix будет передан 0, т.е. ложное значение.
Следовательно в качестве основания будет использоваться значение по умолчанию - 10.
*ParseInt('1', 10)* успешно выполняет преобразование и возвращает 1.  
&emsp;Для первого элемента массива *radix* = 1. В системе счисления по основанию 1 нет символа '5' и это первый встретившийся в строке символ,
поэтому *ParseInt('5', 1)* возвращает значение NaN.  
&emsp;Для второго элемента массива *radix* = 2. Часть строки '11' успешно преобразуется из двоичной системы счисления в число 3 в десятичной системе счисления. Оставшаяся часть строки с символом '2' игнорируется при обработке т.к. такого символа нет в системе счисления по основанию 2.  
&emsp;В итоге в результате работы скрипта будет возвращён массив [1, NaN, 3].



